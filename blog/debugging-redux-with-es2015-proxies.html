<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Proxies are a new feature of ES2015.  By using them, you can avoid one of the most common mistakes made when building applications using Redux.">
  <meta property="og:url" content="https://www.rallycoding.com/blog/debugging-redux-with-es2015-proxies/" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Debugging Redux with ES2015 Proxies" />
  <meta property="og:description" content="Proxies are a new feature of ES2015.  By using them, you can avoid one of the most common mistakes made when building applications using Redux." />
  <meta property="og:image" content="https://s3-us-west-2.amazonaws.com/rallycodingsite/site/mockup.png" />
  <meta property="og:image:width" content="1792" />
  <meta property="og:image:height" content="963" />

  <title>RallyCoding: Debugging Redux with ES2015 Proxies</title>
  <link href="//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.9/semantic.min.css" />
  <link rel="stylesheet" type="text/css" href="../assets/css/prism.a71935aa0da6.css">
  <link rel="stylesheet" type="text/css" href="../assets/css/post.4bcdee4fe9d4.css">

</head>
<body>
  <section id="hero">
    <div class="ui container">
      <div id="header" class="ui borderless menu">
        <div class="header item">
          <h4 id="logo" onclick="document.location.href='/'">
            RallyCoding
          </h4>
        </div>
        <div id="nav" class="right menu">
          <a class="item nav-courses " href="/courses">Courses</a>
          <a class="item nav-blog " href="/blog">Blog</a>
          <a class="item nav-videos " href="/videos">Videos</a>
        </div>
      </div>
    </div>
  </section>

  <section id="post" class="ui container">
    <h1>Debugging Redux with ES2015 Proxies</h1>
    <p style="color: grey;"><em>by Alec Barlow</em></p>

    <br>
    <p>Christopher asks the following:</p>
    <blockquote>
      <p>Hi, I found it quite tedious exporting and importing all those type consts, so did this instead:</p>
      <pre>
        <code class="language-jsx">export const ActionTypes = {
          EmailChanged: &#39;email_changed&#39;,
          PasswordChanged: &#39;password_changed&#39;,
          LoginUserStarted: &#39;login_user_started&#39;,
          LoginUserSuccess: &#39;login_user_success&#39;,
          LoginUserFail: &#39;login_user_fail&#39;,
          EmployeeUpdate: &#39;employee_update&#39;
          };
          import { ActionTypes } from &#39;./types.js&#39;;

          export const emailChanged = (text) =&gt; ({
          type: ActionTypes.EmailChanged,
          payload: text
          });
        </code>
      </pre>
      <p>Any downside to that?</p>
    </blockquote>
    <p>I really like this idea. If we end up with the same functionality with less code redundancy, great! However, doing this may create some unintended consequences, making the app more difficult to debug.</p>

    <p>For example, let's consider of the most common problems that I run into when using Redux: trying to figure out why an action is not being captured by a reducer. For someone just getting starting with Redux, debugging this issue can be especially overwhelming because of how Redux manages data flow.</p>

    <p>In any application that I have built, most bugs that I have run into are simply due to typos. However, the solution to this particular problem is harder to spot because no errors are raised when the application is run. Take a look at the snippet below.</p>

    <pre>
      <code class="language-jsx">// types.js
        export const ActionTypes = {
        EmailChanged: &#39;email_changed&#39;,
        PasswordChanged: &#39;password_changed&#39;,
        LoginUserStarted: &#39;login_user_started&#39;,
        LoginUserSuccess: &#39;login_user_success&#39;,
        LoginUserFail: &#39;login_user_fail&#39;,
        EmployeeUpdate: &#39;employee_update&#39;
        };
        // authReducer.js

        import {
          ActionTypes
        } from &#39;../actions/types&#39;;

        const authReducer = (state = {}, action) =&gt; {
          switch (action.type) {
            case ActionTypes.LoginUserSucess:
              return { ...state, user: action.payload };
            default:
              return state;
          }
        }

        export default authReducer;
      </code>
    </pre>

    <p>Assuming we dispatched an action with type <code>LoginUserSuccess</code>, the <code>authReducer</code> should catch the action before the default case is returned. But what if that is not happening? Where do we start the debugging process. There does not appear to be anything wrong with the code in the reducer; the action type was imported and matches the case in the switch statement. There are no errors in the browser. Where is the issue?</p>

    <p>You may have noticed that I misspelled <code>success</code> in authReducer.js, but the reason this can be hard to catch is because undefined cases do not cause an error. When we define <code>case ActionTypes.LoginUserSucess:</code>, its value is actually undefined, so our reducer always hits the default case.</p>

    <p>Now, there <em>are</em> tools out there to help us catch this. Unfortunately, linters really will not help here; creating a custom rule to disallow undefined object properties will create other problems for us. Using Flow or TypeScript will solve the problem, but many projects do not use them. Also, if you are new to React, adding in Flow or switching to TypeScript probably is not on your radar.</p>

    <h4>Enter Proxies</h4>

    <p>Proxies are a feature of ES2015 that allow us to customize operations on a object. They can be used in many different ways, and you can find some useful examples <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">here</a> and <a href="https://developers.google.com/web/updates/2016/02/es2015-proxies">here</a>. For our problem, this example from <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Validation">Mozilla</a> looks promising:</p>
    <pre>
      <code class="language-jsx">let validator = {
        set: function(obj, prop, value) {
          if (prop === &#39;age&#39;) {
            if (!Number.isInteger(value)) {
              throw new TypeError(&#39;The age is not an integer&#39;);
            }
            if (value &gt; 200) {
              throw new RangeError(&#39;The age seems invalid&#39;);
            }
          }

            // The default behavior to store the value
            obj[prop] = value;

            // Indicate success
            return true;
          }
        };

        let person = new Proxy({}, validator);

        person.age = 100;
        console.log(person.age); // 100
        person.age = &#39;young&#39;; // Throws an exception
        person.age = 300; // Throws an exception
      </code>
    </pre>
    <p>If proxies can be used to validate that properties assigned to an object are of a certain type and value, we can definitely use it to ensure that our action types are never undefined. Letâ€™s refactor our types.js file.</p>

    <pre>
      <code class="language-jsx">// types.js
        const ActionTypes = {
        EmailChanged: &#39;email_changed&#39;,
        PasswordChanged: &#39;password_changed&#39;,
        LoginUserStarted: &#39;login_user_started&#39;,
        LoginUserSuccess: &#39;login_user_success&#39;,
        LoginUserFail: &#39;login_user_fail&#39;,
        EmployeeUpdate: &#39;employee_update&#39;
        };

        const typeValidator = {
        get(obj, prop) {
          if (obj[prop]) {
            return prop;
          } else {
            throw new TypeError(`${prop} is not a valid action type`);
          }
        }
        };

        module.exports = new Proxy(ActionTypes, typeValidator);
      </code>
    </pre>

    <p>First, we define a object containing all our action types. Then we define our validator handler <code>typeValidator</code>. The <code>get()</code> method inside our handler is called a trap, and provides access to the properties of a object. If the property we are looking for, an action type, in this case, exists in <code>ActionTypes</code>, return that prop, unmodified. Otherwise, throw an error because the prop does not exist.</p>

    <p>Finally, export a new proxy, passing <code>ActionTypes</code> as the target and <code>typeValidator</code> as the handler. However, it is important to note that the ES2015 module system does not work well with proxies, so <code>module.exports</code> and <code>require()</code> must be used for exporting and importing the types.</p>

    <p>Barely any code needs to change in the reducer and action creator files, but in order for the action types to be imported successfully, we just need one of code in a new file:</p>

    <pre>
      <code class="language-jsx">// typesProxy.js
        export const ActionTypes = require(&#39;./types&#39;);

        // Also, in the reducer and action creator files,
        // change the import path &#39;/types&#39; to
        // &#39;/typesProxy&#39;
      </code>
    </pre>
    <p>By creating a proxy to verify the existence of an action type, we no longer have to worry about incorrectly naming it because an error will be thrown in the browser console as soon as the application starts:<br>
      <code style="color: red;">Uncaught TypeError: LoginUserSucess is not a valid action type</code>
    </p>
    <p>Reduce the headaches you get when developing an application using Redux and start using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">proxies</a>.</p>
    <div id="post-controls">
      <a href="/blog/reducing-boilerplate-around-axios-requests-with-jwts.html" class="ui labeled left floated icon button">
        <i class="left arrow icon"></i>
        Previous Post
      </a>
      <a href="/blog/the-buttons-arent-alright.html" class="ui right labeled right floated icon button">
        <i class="right arrow icon"></i>
        Next Post
      </a>
    </div>
    <div class="vertical-space-80"></div>
  </section>

  <div id="disqus_thread" class="ui container">

  </div>
  <script src="../assets/js/prism.44ed291397f3.js"></script>

  <script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
    var disqus_config = function() {
      this.page.url = 'https://www.rallycoding.com/blog/debugging-redux-with-es2015-proxies.html';
      this.page.identifier = 'rallycoding-post-5';
    };

    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document,
        s = d.createElement('script');
      s.src = 'https://rallycoding.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</body>

</html>